---
title: "Class 4: Graphical Visualization"
execute:
  echo: true
  eval: false
  message: false
  warning: false
---

```{r}
#| echo: false
#| eval: true

source(here::here("prerender.R"))

```

Graphical visualization is an essential skill for anyone working with data. Graphical visualization requires a combination of design principles with statistical understanding. In general there are two purposes for needing to graphically visualize data:

1)  **Data exploration**: It is difficult to fully understand your data just by looking at numbers on a screen arranged in rows and columns. Being skilled in the graphical visualization of data will help you better understand patterns and relationships that exist in your data.
2)  **Explain and Communicate**: Graphical visualization is the most effective way of explaining and communicating your statistical findings to colleagues, in scientific presentations and publications, and especially to a broader non-academic audience.

## ggplot2

In this class, we will learn about the fundamentals of graphical visualization using the `ggplot2` package. This is by far the most popular package for graphical visualization in R.

![](images/ggplot2.jpg){width="104"}

You have already seen and even used `ggplot2` in previous classes, but now we will cover how to actually use this package. The elements for creating a **ggplot** was largely inspired from the work of Leland Wilkinson (Grammar of Graphics, 1999), who formalized two main principles in plotting data:

1.  Layering: The idea of layering involves building plots by adding different layers of **grammatical elements**. Each layer can consist of components such as points, lines, bars, etc., and can be combined to create complex plots.
2.  Mapping: This principle involves mapping variables in your data to aesthetic properties of the graphical objects, such as size, shape, color, position, and the scales on the x and y axes.

In this framework, the essential **grammatical elements** required to create any visualization are:

![](images/ge_essentials.png){width="587"}

Let's take a look at how these elements work to create a simple visualization of data. In Class 1 I introduced you to the fun `palmerpenguins` data set. I will use this data set to illustrate how `ggplot2` works.

![](images/lter_penguins.png){fig-align="center" width="677"}

Go ahead and load the `palmerpenguins` and `ggplot2` packages using `library()` . Additionally, let's make the `penguins` data set that is loaded with `palmerpenguins` visible in the environment by explicitly assigning it to an object.

```{r}
#| echo: false
#| eval: true

library(palmerpenguins)
library(ggplot2)

```

```{r}
penguins <- penguins
```

## Data layer

The Data Layer specifies the data object that is being plotted.

![](images/ge_data.png){width="400"}

It is the first element that gets specified:

```{r}
#| eval: true

ggplot(data = penguins)
```

You can see that we only have a blank square. This is because we have not added any other layers yet, we have only specified the data layer. `ggplot()` doesn't yet know how to map the variables onto the axis scales. That is where the aesthetic mapping layer comes in.

## Aesthetics Layer

The next grammatical element is the aesthetic layer, or **aes** for short. This layer specifies how we want to *map* our data onto the scales of the plot.

![](images/ge_aes.png){width="400"}

The aesthetic layer *maps* variables in our data onto scales in our graphical visualization, such as the x and y coordinates. In `ggplot2` the aesthetic layer is specified using the `aes()` function. Let's create a plot of the relationship between `bill_length_mm` and `flipper_length_mm`, putting them on the x and y axis respectively.

```{r}
#| eval: true

ggplot(penguins, mapping = aes(x = bill_length_mm, y = flipper_length_mm))

```

You can see we went from a blank box to a graph with the variable and scales of `bill_length_mm` mapped onto the x-axis and `flipper_length_mm` on the y-axis.

The aesthetic layer also maps variables in our data to other elements in our graphical visualization, such as color, size, fill, etc. These other elements are useful for adding a third variable into our graphical visualizations. For instance, we can add the variable of `species` by mapping `species` onto the color aesthetic.

```{r}
#| eval: true

ggplot(penguins, mapping = aes(x = bill_length_mm, y = flipper_length_mm,
                               color = species))

```

You will notice that the plot has not changed. Species is not plotted by color. This is because `ggplot()` does not know the geometrical form the data should take - a bar plot, line plot, dot plot, etc.? It cannot add color to a geometrical form that is not specified yet. That is where the geometries layer comes in.

## Geometries Layer

The next *essential* grammatical element for graphical visualization is the geometries layer or **geom** for short. This layer specifies the actual visual elements to use to plot the actual data.

![](images/ge_geom.png){width="400"}

There are a lot of different types of **geoms** to use in ggplot2. Some of the most commonly used ones are:

-   Points or jittered points: `geom_point()` or `geom_jitter()`

-   Lines: `geom_line()`

-   Bars: `geom_bar()`

-   Violin: `geom_violin()`

-   Error bars: `geom_errobar()` or `geom_ribbon()`

For a full list see the [ggplot2 documentation](https://ggplot2.tidyverse.org/reference/#geoms){target="_blank"}

------------------------------------------------------------------------

For now, let's demonstrate this using `geom_point()`. We will create what is called a **scatterplot** - plotting the individual data points for two continuous variables.

To create a scatterplot we can simply add `geom_point()` to our ggplot. Note that in `ggplot2` there is a special notation that is similar to the pipe operator `|>` seen before. Except in `ggplot2` you have to use a plus sign `+` .

```{r}
#| eval: true

ggplot(penguins, aes(x = bill_length_mm, y = flipper_length_mm,
                     color = species)) +
  geom_point()
```

Note you can also specify the `color = species` aesthetic mapping on the geometric layer instead of the data layer:

```{r}

ggplot(penguins, aes(x = bill_length_mm, y = flipper_length_mm)) +
  geom_point(mapping = aes(color = species))
```

So you can see that the three essential grammatical elements for any graphical visualization are the:

-   Data

-   Aesthetics

-   Geometries

However, there are often other types of elements you want to include to modify the design of the graphical visualization.

![](images/ge_all.png){width="550"}

## Facets Layer

The facet layer allows you to create panels of subplots within the same graphic object

![](images/ge_facet.png){width="400"}

The previous three layers are the **essential** layers. The facet layer is not essential, however given your data you may find it helps you to explore or communicate your data. This is useful when you want to communicate the relationshpi among 4 or more variables.

Let's create a facet layer of our scatterplot with different panels for `sex`

```{r}
#| eval: true

# first let's remove any missing values for sex
library(dplyr)
penguins <- filter(penguins, !is.na(sex))

ggplot(penguins, aes(bill_length_mm, flipper_length_mm,
                     color = species)) +
  geom_point() +
  facet_wrap(vars(sex))
```

You can see we are now conveying information about 4 different variables in our data; `bill_length_mm`, `flipper_length_mm`, `species`, and `sex` .

## Statistics Layer

The statistics layer allows you plot aggregated statistical values calculated from your data

![](images/ge_stats.png){width="400"}

The statistics layer is used in combination with a **geom** to plot values that are a function (e.g., mean) of the values in your data. The two main **stat** functions are:

-   `stat_smooth()`

-   `stat_summary()`

`stat_smooth(method = "lm")` is used in scatterplots to plot the regression line on your data.

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = flipper_length_mm)) +
  geom_point() +
  stat_smooth(method = "lm")
```

You can add separate regression lines if other variables are mapped to **aesthetics** or are wrapped in different **facets**

```{r}
ggplot(penguins, aes(bill_length_mm, flipper_length_mm,
                     color = species)) +
  geom_point() +
  facet_wrap(vars(sex)) +
  stat_smooth(method = "lm")
```

`stat_summary()` can be used to plot things like the **mean** values in your data. There are two main arguments you need to specify in `stat_summary()`:

-   **fun**: The function used to calculate an aggregated summary statistic. Functions like **mean**, **sum**, **min**, **max**, **sd** can all be specified. You can then specify additional argument that should be passed into these functions as regular arguments in `stat_summary()`. E.g., `stat_summary(fun = mean, na.rm = TRUE)`

-   **geom**: The `geom_()` graphical element you want to use as the visual element for the data

```{r}
#| eval: true

ggplot(penguins, aes(species, flipper_length_mm)) +
  stat_summary(fun = mean, geom = "point")
```

Compare this with using a **line** geom.

```{r}
#| eval: true

ggplot(penguins, aes(species, flipper_length_mm)) +
  stat_summary(fun = mean, geom = "line", group = 1)

```

Without specifiying a **geom** the mean values would not be plotted.

The **fun** argument returns only a single summary statistic value. However, there are cases when you will want to return more than one value, for instance when plotting errorbars you will need both the ymin and ymax values returned. For these types of cases, you need to use the **fun.data** argument instead:

```{r}
#| eval: true

ggplot(penguins, aes(species, flipper_length_mm)) +
  stat_summary(fun = mean, geom = "point", group = 1) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar")
```

## Coordinates Layer

The coordinate layer allows you to adjust the x and y coordinates

![](images/ge_coord.png){width="400"}

There are two main groups of functions that are useful for adjusting the x and y coordinates.

-   `coord_cartesian()` for adjusting the axis limits (zoom in and out)

-   `scale_x_` and `scale_y_` for setting the axis ticks and labels

### axis limits

You can adjust limits (min and max) of the x and y axes using the `coord_cartesian(xlim = "", ylim = "")` function.

**If you want to compare two separate graphs, then they need to be on the same scale!** This an important design principle in graphical visualization.

Compare these two sets of plots

```{r}
#| eval: true

male <- filter(penguins, sex == "male")
female <- filter(penguins, sex == "female")

p1 <- ggplot(male, aes(species, body_mass_g)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar") +
  coord_cartesian(ylim = c(2000, 10000))

p2 <- ggplot(female, aes(species, body_mass_g)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar") + 
  coord_cartesian(ylim = c(3000, 5000))
```

```{r}
#| eval: true

library(patchwork)

p1 + labs(title = "male") + p2 + labs(title = "female")

```

A cursory look at this plot, you might conclude a couple things

-   **Female Gentoo** penguins have the largest body mass

-   There is a larger difference in body mass, relative to the other penguin species, for the **Female Gentoo** penguins than for **Male Gentoo** penguins.

These are both false! Take a closer look at the y-axis on the two plots. Let's plot the **exact same data** but make the scales on the y-axis the same. What a difference!

```{r}
#| eval: true

p1 <- ggplot(male, aes(species, body_mass_g)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar") +
  coord_cartesian(ylim = c(3000, 6000)) +
  labs(title = "male")

p2 <- ggplot(female, aes(species, body_mass_g)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar") + 
  coord_cartesian(ylim = c(3000, 6000)) +
  labs(title = "female")

```

```{r}
#| eval: true

p1 + labs(title = "male") + p2 + labs(title = "female")

```

### axis ticks and labels

You can adjust the scale (major and minor ticks) of the x and y axes using the `scale_x_` and `scale_y_` sets of functions. The two main sets of functions to know are for continuous and discrete scales:

-   continuous: `scale_x_continuous(breaks = seq())` and `scale_y_continuous(breaks = seq())`

-   discrete: `scale_x_discrete(breaks = c())` and `scale_y_continuous(breaks = c())`

For example:

```{r}
#| eval: true

p1 <- ggplot(male, aes(species, body_mass_g)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar") +
  coord_cartesian(ylim = c(3000, 6000)) +
  scale_y_continuous(breaks = seq(3000, 6000, by = 500))

p2 <- ggplot(female, aes(species, body_mass_g)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar") + 
  coord_cartesian(ylim = c(3000, 6000)) +
  scale_y_continuous(breaks = seq(3000, 6000, by = 500))
```

```{r}
#| eval: true

p1 + labs(title = "male") + p2 + labs(title = "female")
```

## Theme Layer

The theme layer refers to visual elements that are not mapped to the data but controls the overall design, colors, and labels on the plot

![](images/ge_themes.png){width="400"}

There are three main set of functions that we can use to control the theme layer:

-   **Labels**: `labs()` is a convenient function for labelling the title, subtitle, axes, and legend

-   **Color**: `scale_color_` sets of functions will change the color scheme of the geometric elements:

    -   `scale_color_manual()`

    -   `scale_color_brewer()`

-   **Theme templates**:

    -   `theme_minimal()`

-   **Other theme elements**: `theme()`

### Labels

something

### Color

something

### Theme templates

something

### Customize Your Own Theme

something
